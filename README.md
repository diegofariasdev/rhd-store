## SuperStore ##

Superstore is an e-store I developed to apply to a company 
as FullStack Engineer.

It is a Spring Boot application based on REST Services, 
with frontend written in React.

### Backend ###

Superstore backend makes use of a wide range of Spring and 
Spring Boot utilities. The service layer consist of three 
main controllers that allow a client to perform the basic 
actions of an online store.

1. /items

|Method|Path|Url Params|Headers|Request|Response|
|------|----|----------|-------|-------|--------|
|GET|/|?search=\<search\> <br /> &orderBy=desc(price) <br /> &pageSize=5 <br /> &pageNumber=0|Content-type: application/json| |Page of items|
|GET|/\<itemcode\>| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>| |Single item|
|POST|/| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>|Single item|Single item|
|PUT|/| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>|Single item|Single item|

2. /orders

|Method|Path|Url Params|Headers|Request|Response|
|------|----|----------|-------|-------|--------|
|POST|/| |Content-type: application/json <br /> Authorization: Bearer \<client_jwt_token\>|Single order|Single order|
|PUT|/| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>|Single order|Single order|
|GET|/|?username=\<username\> <br /> &startDate=\<yyyy/MM/dd\> <br /> &endDate=\<yyyy/MM/dd\> <br /> &orderBy=desc(creationTimestamp) <br /> &pageSize=5 <br /> &pageNumber=0|Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>| |Page of orders|
|GET|/client/\<username\>|?orderBy=desc(creationTimestamp) <br /> &pageSize=5 <br /> &pageNumber=0|Content-type: application/json <br /> Authorization: Bearer \<client_jwt_token\>| |Page of orders|
|GET|/\<ordercode\>| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>| |Single order|

3. /users

|Method|Path|Url Params|Headers|Request|Response|
|------|----|----------|-------|-------|--------|
|POST|/login| |Content-type: application/json|Single user|Access Token|
|POST|/| |Content-type: application/json|Single user|Single user|
|PUT|/| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>|Single user|Single user|
|GET|/|?profile=\<profile\> <br /> &enable=\<enable\> <br /> &orderBy=desc(creationTimestamp) <br /> &pageSize=5 <br /> &pageNumber=0|Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>| |Page of users|
|GET|/\<username\>| |Content-type: application/json <br /> Authorization: Bearer \<admin_jwt_token\>| |Single users|

I used Hibernate Bean Validation (https://hibernate.org/validator/) to 
validate the input of the endpoints, this includes requests body, path
variables and url params.

I used Spring JPA Repositories to follow the DAO pattern and to support
pagination. The PagingAndSortingRepository interface provides most of
the necessary features out-of-the-box and complimentary methods are
easy to include.

For the JWT generation and validation, This article was very useful:
https://www.toptal.com/spring/spring-security-tutorial
My implementation auth service is based primarily on the code from the
article.

### Frontend ###

The frontend is fully written in React. I used the grommet 
(https://v2.grommet.io/components) library/framework, that 
provides many useful and pretty components to build responsive sites.

For paginated tables I used the react-table library 
(https://www.npmjs.com/package/react-table). This library allowed me
to handle pagination and sorting in the backend, lowering the memory
footprint in the browser.

The JWT token is stored in localStorage, this way we avoid cookies,
anyway I'd prefer to store it in an httpOnly cookie.

### Highlights ###

* The UI is responsive for a web browser, it might need some work to 
  be usable in a smartphone.

* All the pagination is done in the backend, improving the memory 
  footprint.

* I followed the rule not to exposed DB autogenerated IDs to the 
  API client, instead of DB IDs, every object, either it is an item,
  or an order, has a code that identifies it.

### Running project ###

#### Cloud ####

The store is deployed to GCP: https://rhd-store.uc.r.appspot.com/#/

#### Run locally ####

These instructions work for a Bash CLI and were tested using the
following software:

* java 1.8.0_271
* maven 3.6.3
* nodeJs v10.24.0
* npm 6.14.11 
* MySQL 5.7

1. Create a schema in a MySQL 5.7 server and execute the scripts in 
_database_ folder in ascendant order

2. Execute the following command in the root folder of the project

```bash
SPRING_PROFILES_ACTIVE=local\
mvn spring-boot:run\
-Ddatabase.connectionUrl=jdbc:mysql://localhost:3306/store\
-Ddatabase.username=root\
-Ddatabase.password=root
```

The application includes a compiled version of the frontend and is
available on: http://localhost:8080 

#### Run locally + UI ####

To execute the UI in its own server, follow the instructions of the
previous section and execute the following command in the store-ui
folder

```bash
npm start
```

The UI is configured to proxy API calls to http://localhost:8080/, so
it's important to have the backend up and running

The UI is accessible in http://localhost:3000

### Sample Data ###

Some sample data to play with in the cloud deployed app:

* The first admin user is generated when building the DB schema. 

* I'm an aficionado of rubik puzzles, so I decided to sell rubik 
  cubes in superstore, I took the details of the puzzles from
  HK Now Store (https://www.hknowstore.com/)
  
* Some users to test are:
  
|User|Password| 
|----|--------|
|admin|4dm1n|
|alex|facil123|
|javi|facil123|

### Future work ###

I'd like to do some enhancements to the online store, for instance:
* Add confirmation modals to the UI.
* Implement refresh token.
* Improve the DTOs code, encapsulating fields.
* Improve the DAOs with custom queries, that way I don't have to null
  the IDs of all the objects.
* Allow users to modify their own data.
* Add stock information:
    * Hide items out of stock.
    * Validate that the item is available during checkout.
* Stock and sales reports.